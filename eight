#!/usr/bin/env python3
"""
Eight Sleep CLI - Control your Eight Sleep Pod from the terminal.

Usage:
    eight status          Show current status
    eight temp 68F        Set temperature
    eight on / off        Turn on/off
    eight doctor          Health check
"""

import argparse
import gzip
import json
import os
import sys
import time
from dataclasses import dataclass
from datetime import datetime, timedelta, timezone
from enum import Enum
from pathlib import Path
from typing import Any, Dict, Optional, Tuple
import urllib.request
import urllib.error

__version__ = "0.4.0"

# ─────────────────────────────────────────────────────────────────────────────
# Configuration
# ─────────────────────────────────────────────────────────────────────────────

# API endpoints (reverse-engineered from pyEight / Android APK)
AUTH_URL = "https://auth-api.8slp.net/v1/tokens"
CLIENT_API_URL = "https://client-api.8slp.net/v1"
APP_API_URL = "https://app-api.8slp.net/v1"

# OAuth credentials (extracted from Eight Sleep Android APK)
CLIENT_ID = "0894c7f33bb94800a03f1f4df13a4f38"
CLIENT_SECRET = "f0954a3ed5763ba3d06834c73731a32f15f168f47d4f164751275def86db0c76"

DEFAULT_HEADERS = {
    "Content-Type": "application/json",
    "Accept": "application/json",
    "Accept-Encoding": "gzip, deflate",
    "User-Agent": "okhttp/4.9.3",
    "Connection": "keep-alive",
}

# File paths
CONFIG_DIR = Path.home() / ".config" / "eight"
CONFIG_FILE = CONFIG_DIR / "config.json"
TOKEN_FILE = CONFIG_DIR / "token.json"
CACHE_FILE = CONFIG_DIR / "cache.json"

# Cache settings
CACHE_MAX_AGE_SECONDS = 3600  # 1 hour for fallback use
CACHE_STALE_THRESHOLD = 300  # 5 minutes before considered stale

# Global state
VERBOSE = False

# Temperature conversion tables (from Eight Sleep app)
RAW_TO_FAHRENHEIT = {
    -100: 55, -90: 57, -80: 59, -70: 61, -60: 63, -50: 66, -40: 68, -30: 70,
    -20: 72, -10: 75, 0: 77, 10: 80, 20: 82, 30: 85, 40: 88, 50: 91,
    60: 94, 70: 97, 80: 100, 90: 104, 100: 110
}

RAW_TO_CELSIUS = {
    -100: 13, -90: 14, -80: 15, -70: 16, -60: 17, -50: 19, -40: 20, -30: 21,
    -20: 22, -10: 24, 0: 25, 10: 27, 20: 28, 30: 29, 40: 31, 50: 33,
    60: 34, 70: 36, 80: 38, 90: 40, 100: 44
}


# ─────────────────────────────────────────────────────────────────────────────
# Data Source Tracking
# ─────────────────────────────────────────────────────────────────────────────

class DataSource(Enum):
    """Indicates where data came from."""
    LIVE = "live"
    CACHED = "cached"


@dataclass
class FetchResult:
    """Result of a data fetch with source information."""
    data: Dict[str, Any]
    source: DataSource
    age_seconds: int = 0

    @property
    def is_live(self) -> bool:
        return self.source == DataSource.LIVE

    @property
    def is_stale(self) -> bool:
        return self.age_seconds > CACHE_STALE_THRESHOLD

    def source_indicator(self) -> str:
        """Return a human-readable source indicator."""
        if self.source == DataSource.LIVE:
            return "[LIVE]"
        else:
            age_str = format_age(self.age_seconds)
            return f"[CACHED {age_str} ago]"


def format_age(seconds: int) -> str:
    """Format age in human-readable form."""
    if seconds < 60:
        return f"{seconds}s"
    elif seconds < 3600:
        return f"{seconds // 60}m"
    else:
        return f"{seconds // 3600}h {(seconds % 3600) // 60}m"


# ─────────────────────────────────────────────────────────────────────────────
# Logging
# ─────────────────────────────────────────────────────────────────────────────

def log(msg: str) -> None:
    """Print debug message if verbose mode is enabled."""
    if VERBOSE:
        print(f"[DEBUG] {msg}", file=sys.stderr)


def error(msg: str) -> None:
    """Print error message to stderr."""
    print(f"Error: {msg}", file=sys.stderr)


# ─────────────────────────────────────────────────────────────────────────────
# File Management (Config, Token, Cache)
# ─────────────────────────────────────────────────────────────────────────────

def ensure_config_dir() -> None:
    """Ensure config directory exists with proper permissions."""
    CONFIG_DIR.mkdir(parents=True, exist_ok=True)


def load_json_file(path: Path) -> Optional[Dict]:
    """Load JSON file, return None if missing or invalid."""
    if not path.exists():
        return None
    try:
        with open(path) as f:
            return json.load(f)
    except (json.JSONDecodeError, OSError) as e:
        log(f"Failed to load {path}: {e}")
        return None


def save_json_file(path: Path, data: Dict, secure: bool = True) -> None:
    """Save JSON file with optional secure permissions."""
    ensure_config_dir()
    with open(path, "w") as f:
        json.dump(data, f, indent=2)
    if secure:
        os.chmod(path, 0o600)


def load_config() -> Dict:
    """Load user configuration (email/password)."""
    return load_json_file(CONFIG_FILE) or {}


def save_config(config: Dict) -> None:
    """Save user configuration."""
    save_json_file(CONFIG_FILE, config, secure=True)


def load_token() -> Optional[Dict]:
    """Load cached auth token if still valid."""
    token = load_json_file(TOKEN_FILE)
    if token and token.get("expires_at", 0) > time.time() + 120:
        return token
    return None


def save_token(token: Dict) -> None:
    """Save auth token."""
    save_json_file(TOKEN_FILE, token, secure=True)


# ─────────────────────────────────────────────────────────────────────────────
# Cache Management
# ─────────────────────────────────────────────────────────────────────────────

def load_cache() -> Dict:
    """Load the full cache."""
    return load_json_file(CACHE_FILE) or {}


def save_to_cache(key: str, data: Dict) -> None:
    """Save data to cache with timestamp."""
    cache = load_cache()
    cache[key] = {
        "data": data,
        "timestamp": time.time(),
        "time_str": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    }
    save_json_file(CACHE_FILE, cache, secure=False)
    log(f"Cached {key}")


def get_from_cache(key: str, max_age: int = CACHE_MAX_AGE_SECONDS) -> Tuple[Optional[Dict], int]:
    """
    Get cached data if not too old.
    Returns (data, age_seconds) or (None, 0).
    """
    cache = load_cache()
    if key not in cache:
        return None, 0

    entry = cache[key]
    age = int(time.time() - entry.get("timestamp", 0))
    if age < max_age:
        log(f"Cache hit for {key} (age: {age}s)")
        return entry.get("data"), age

    log(f"Cache expired for {key} (age: {age}s > max: {max_age}s)")
    return None, 0


# ─────────────────────────────────────────────────────────────────────────────
# HTTP / API Layer
# ─────────────────────────────────────────────────────────────────────────────

def decode_response(resp) -> bytes:
    """Decode HTTP response, handling gzip compression."""
    data = resp.read()
    if resp.headers.get("Content-Encoding") == "gzip":
        data = gzip.decompress(data)
    return data


def api_request(
    method: str,
    url: str,
    data: Optional[Dict] = None,
    token: Optional[str] = None,
    retries: int = 3,
    backoff: float = 1.0
) -> Dict:
    """
    Make an API request with retry and exponential backoff.

    Raises RuntimeError on failure.
    """
    headers = DEFAULT_HEADERS.copy()
    if token:
        headers["Authorization"] = f"Bearer {token}"

    body = json.dumps(data).encode() if data else None
    last_error: Optional[Exception] = None

    log(f"{method} {url}")
    if data:
        log(f"  Body: {json.dumps(data)}")

    for attempt in range(retries):
        try:
            req = urllib.request.Request(url, data=body, headers=headers, method=method)
            with urllib.request.urlopen(req, timeout=30) as resp:
                result = json.loads(decode_response(resp).decode())
                log(f"  Response: {resp.status} OK")
                return result

        except urllib.error.HTTPError as e:
            error_body = decode_response(e).decode()
            log(f"  HTTP {e.code}: {error_body[:200]}")

            # Rate limited - retry with backoff
            if e.code == 429:
                wait = backoff * (2 ** attempt)
                print(f"Rate limited. Waiting {wait:.1f}s...", file=sys.stderr)
                time.sleep(wait)
                last_error = e
                continue

            # Auth error - don't retry
            if e.code in (401, 403):
                try:
                    err = json.loads(error_body)
                    raise RuntimeError(f"Auth error: {err}")
                except json.JSONDecodeError:
                    raise RuntimeError(f"Auth error {e.code}: {error_body}")

            # Other HTTP error
            try:
                err = json.loads(error_body)
                raise RuntimeError(f"API error {e.code}: {err}")
            except json.JSONDecodeError:
                raise RuntimeError(f"API error {e.code}: {error_body}")

        except urllib.error.URLError as e:
            log(f"  Connection error: {e.reason}")
            last_error = e
            if attempt < retries - 1:
                wait = backoff * (2 ** attempt)
                print(f"Connection error. Retrying in {wait:.1f}s...", file=sys.stderr)
                time.sleep(wait)
                continue
            raise RuntimeError(f"Connection failed: {e.reason}")

    raise RuntimeError(f"Max retries exceeded: {last_error}")


# ─────────────────────────────────────────────────────────────────────────────
# Authentication
# ─────────────────────────────────────────────────────────────────────────────

def authenticate(email: str, password: str) -> Dict:
    """Authenticate with Eight Sleep and return token data."""
    log(f"Authenticating as {email}...")

    result = api_request("POST", AUTH_URL, {
        "client_id": CLIENT_ID,
        "client_secret": CLIENT_SECRET,
        "grant_type": "password",
        "username": email,
        "password": password,
    })

    token_data = {
        "access_token": result["access_token"],
        "user_id": result["userId"],
        "expires_at": time.time() + result.get("expires_in", 3600),
    }
    save_token(token_data)

    log(f"Authenticated successfully, user_id={token_data['user_id']}")
    return token_data


def get_token() -> Dict:
    """Get valid auth token, refreshing if necessary."""
    token = load_token()
    if token:
        expires_in = int(token["expires_at"] - time.time())
        log(f"Using cached token, expires in {expires_in}s")
        return token

    # Re-authenticate using saved credentials
    config = load_config()
    email = config.get("email")
    password = config.get("password")

    if not email or not password:
        error("Not configured. Run 'eight login' first.")
        sys.exit(1)

    return authenticate(email, password)


# ─────────────────────────────────────────────────────────────────────────────
# Eight Sleep API Endpoints
# ─────────────────────────────────────────────────────────────────────────────

def api_get_user(token: Dict) -> Dict:
    """Get current user data."""
    return api_request("GET", f"{CLIENT_API_URL}/users/me", token=token["access_token"])


def api_get_device(token: Dict, device_id: str) -> Dict:
    """Get device data."""
    return api_request("GET", f"{CLIENT_API_URL}/devices/{device_id}", token=token["access_token"])


def api_get_temperature(token: Dict, user_id: str) -> Dict:
    """Get temperature settings for a user."""
    return api_request("GET", f"{APP_API_URL}/users/{user_id}/temperature", token=token["access_token"])


def api_set_temperature(token: Dict, user_id: str, level: int) -> Dict:
    """Set temperature level for a user."""
    return api_request("PUT", f"{APP_API_URL}/users/{user_id}/temperature",
                       {"currentLevel": level}, token=token["access_token"])


def api_set_state(token: Dict, user_id: str, state_type: str) -> Dict:
    """Set device state (on/off)."""
    return api_request("PUT", f"{APP_API_URL}/users/{user_id}/temperature",
                       {"currentState": {"type": state_type}}, token=token["access_token"])


def api_get_trends(token: Dict, user_id: str, start: str, end: str) -> Dict:
    """Get sleep trends for a date range."""
    return api_request("GET", f"{CLIENT_API_URL}/users/{user_id}/trends?tz=UTC&from={start}&to={end}",
                       token=token["access_token"])


def api_get_alarms(token: Dict, user_id: str) -> Dict:
    """Get alarms for a user."""
    return api_request("GET", f"{APP_API_URL}/users/{user_id}/alarms", token=token["access_token"])


def api_set_alarm(token: Dict, user_id: str, alarm_id: str, data: Dict) -> Dict:
    """Update alarm settings."""
    return api_request("PUT", f"{APP_API_URL}/users/{user_id}/alarms/{alarm_id}",
                       data, token=token["access_token"])


# ─────────────────────────────────────────────────────────────────────────────
# High-Level Data Fetching (with caching)
# ─────────────────────────────────────────────────────────────────────────────

def fetch_temperature(token: Dict, user_id: str, use_cache_fallback: bool = True) -> FetchResult:
    """
    Fetch temperature data, with optional cache fallback on failure.
    Always caches successful results.
    """
    cache_key = f"temperature_{user_id}"

    try:
        data = api_get_temperature(token, user_id)
        save_to_cache(cache_key, data)
        return FetchResult(data=data, source=DataSource.LIVE)

    except RuntimeError as e:
        if use_cache_fallback:
            cached_data, age = get_from_cache(cache_key, max_age=86400)  # Allow 24h cache for fallback
            if cached_data:
                log(f"API failed, using cached data (age: {age}s)")
                return FetchResult(data=cached_data, source=DataSource.CACHED, age_seconds=age)
        raise


def fetch_device_info(token: Dict) -> Tuple[Dict, str, str, str]:
    """
    Get device info and determine user's side.
    Returns (device, device_id, user_id, side).
    """
    user_data = api_get_user(token)
    user_id = token["user_id"]
    devices = user_data.get("user", {}).get("devices", [])

    if not devices:
        raise RuntimeError("No devices found")

    device_id = devices[0]
    device_data = api_get_device(token, device_id)
    device = device_data.get("result", {})

    # Cache device info
    save_to_cache("device", {"device": device, "device_id": device_id, "user_id": user_id})

    # Determine side
    left_user = device.get("leftUserId")
    right_user = device.get("rightUserId")
    side = "left" if left_user == user_id else "right" if right_user == user_id else "unknown"

    return device, device_id, user_id, side


def get_other_user_id(device: Dict, current_side: str) -> Optional[str]:
    """Get the user ID for the other side of the bed."""
    if current_side == "left":
        return device.get("rightUserId")
    elif current_side == "right":
        return device.get("leftUserId")
    return None


# ─────────────────────────────────────────────────────────────────────────────
# Temperature Conversion Utilities
# ─────────────────────────────────────────────────────────────────────────────

def raw_to_temp(raw: int, unit: str = "F") -> int:
    """Convert raw level (-100 to 100) to temperature."""
    mapping = RAW_TO_FAHRENHEIT if unit == "F" else RAW_TO_CELSIUS
    keys = sorted(mapping.keys())
    closest = min(keys, key=lambda k: abs(k - raw))
    return mapping[closest]


def temp_to_raw(temp: int, unit: str = "F") -> int:
    """Convert temperature to raw level."""
    mapping = RAW_TO_FAHRENHEIT if unit == "F" else RAW_TO_CELSIUS
    for raw, t in sorted(mapping.items()):
        if t >= temp:
            return raw
    return 100


def parse_temp_arg(arg: str) -> int:
    """Parse temperature argument (68F, 20C, or raw level)."""
    arg = arg.strip().upper()
    if arg.endswith("F"):
        return temp_to_raw(int(arg[:-1]), "F")
    elif arg.endswith("C"):
        return temp_to_raw(int(arg[:-1]), "C")
    else:
        level = int(arg)
        if -100 <= level <= 100:
            return level
        raise ValueError("Raw level must be between -100 and 100")


def format_temp(level: int) -> str:
    """Format temperature for display."""
    return f"{raw_to_temp(level, 'F')}°F / {raw_to_temp(level, 'C')}°C"


# ─────────────────────────────────────────────────────────────────────────────
# CLI Command Helpers
# ─────────────────────────────────────────────────────────────────────────────

def resolve_user_id(args) -> Tuple[Dict, str, str]:
    """
    Resolve the user ID based on --side flag.
    Returns (token, user_id, side).
    """
    token = get_token()
    device, device_id, user_id, my_side = fetch_device_info(token)

    requested_side = getattr(args, 'side', None)

    if requested_side and requested_side != my_side:
        other_user_id = get_other_user_id(device, my_side)
        if other_user_id:
            return token, other_user_id, requested_side
        else:
            print(f"Warning: No user on {requested_side} side, using {my_side}", file=sys.stderr)

    return token, user_id, my_side


def handle_offline_error(e: Exception) -> None:
    """Handle device offline errors consistently."""
    if "offline" in str(e).lower():
        error("Device offline. Check that your Pod is powered on and connected.")
        sys.exit(1)
    raise e


# ─────────────────────────────────────────────────────────────────────────────
# CLI Commands
# ─────────────────────────────────────────────────────────────────────────────

def cmd_login(args) -> None:
    """Configure credentials."""
    email = args.email or input("Email: ")
    password = args.password or input("Password: ")

    print("Authenticating...")
    try:
        token = authenticate(email, password)
        save_config({"email": email, "password": password})
        print(f"Logged in as user {token['user_id']}")
    except Exception as e:
        error(f"Login failed: {e}")
        sys.exit(1)


def cmd_logout(args) -> None:
    """Clear credentials and cache."""
    for f in [TOKEN_FILE, CONFIG_FILE, CACHE_FILE]:
        if f.exists():
            f.unlink()
    print("Logged out.")


def cmd_status(args) -> None:
    """Show device status."""
    token, user_id, side = resolve_user_id(args)

    try:
        result = fetch_temperature(token, user_id, use_cache_fallback=True)
    except RuntimeError as e:
        handle_offline_error(e)

    temp_data = result.data
    current_level = temp_data.get("currentLevel", 0)
    current_state = temp_data.get("currentState", {}).get("type", "unknown")

    if args.json:
        output = temp_data.copy()
        output["_source"] = result.source.value
        if result.source == DataSource.CACHED:
            output["_cache_age_seconds"] = result.age_seconds
        print(json.dumps(output, indent=2))
        return

    # Show source indicator
    print(f"{result.source_indicator()}")
    print(f"Side:        {side}")
    print(f"State:       {current_state}")
    print(f"Level:       {current_level}")
    print(f"Temperature: {format_temp(current_level)}")


def cmd_temp(args) -> None:
    """Set temperature."""
    token, user_id, side = resolve_user_id(args)
    level = parse_temp_arg(args.level)

    try:
        api_set_temperature(token, user_id, level)
        print(f"Set {side} side to level {level} ({format_temp(level)})")
    except RuntimeError as e:
        handle_offline_error(e)


def cmd_on(args) -> None:
    """Turn on."""
    token, user_id, side = resolve_user_id(args)
    try:
        api_set_state(token, user_id, "smart")
        print(f"Turned on {side} side")
    except RuntimeError as e:
        handle_offline_error(e)


def cmd_off(args) -> None:
    """Turn off."""
    token, user_id, side = resolve_user_id(args)
    try:
        api_set_state(token, user_id, "off")
        print(f"Turned off {side} side")
    except RuntimeError as e:
        handle_offline_error(e)


def cmd_whoami(args) -> None:
    """Show current user and device info."""
    token = get_token()
    device, device_id, user_id, side = fetch_device_info(token)

    online_status = "online" if device.get("online") else "offline"

    print(f"User ID:   {user_id}")
    print(f"Device ID: {device_id}")
    print(f"Side:      {side}")
    print(f"Status:    {online_status}")

    other_id = get_other_user_id(device, side)
    if other_id:
        other_side = "right" if side == "left" else "left"
        print(f"Partner:   {other_id} ({other_side})")


def cmd_presence(args) -> None:
    """Check if someone is in bed."""
    token = get_token()
    device, device_id, user_id, my_side = fetch_device_info(token)

    left_presence = device.get("leftPresence", False)
    right_presence = device.get("rightPresence", False)

    if args.json:
        print(json.dumps({"left": left_presence, "right": right_presence}))
        return

    def status(present: bool) -> str:
        return "in bed" if present else "not in bed"

    if args.side:
        presence = left_presence if args.side == "left" else right_presence
        print(status(presence))
    else:
        print(f"Left:  {status(left_presence)}")
        print(f"Right: {status(right_presence)}")


def cmd_sleep(args) -> None:
    """Show sleep metrics."""
    token, user_id, side = resolve_user_id(args)

    days = args.days or 7
    end_date = datetime.now(timezone.utc)
    start_date = end_date - timedelta(days=days)

    start = start_date.strftime("%Y-%m-%d")
    end = end_date.strftime("%Y-%m-%d")

    trends = api_get_trends(token, user_id, start, end)

    if args.json:
        print(json.dumps(trends, indent=2))
        return

    days_data = trends.get("days", [])
    if not days_data:
        print("No sleep data available.")
        return

    print(f"Sleep data for {side} side ({len(days_data)} nights):\n")

    for day in reversed(days_data[-7:]):
        date = day.get("day", "Unknown")
        score = day.get("score", 0)
        duration_sec = day.get("sleepDuration", 0)
        duration_hrs = duration_sec / 3600 if duration_sec else 0

        hrv = day.get("sleepQualityScore", {}).get("hrv", {}).get("current")
        breath = day.get("sleepQualityScore", {}).get("respiratoryRate", {}).get("current")
        hr = day.get("sleepQualityScore", {}).get("heartRate", {}).get("current")

        print(f"{date}:")
        print(f"  Score:    {score}")
        print(f"  Duration: {duration_hrs:.1f}h")
        if hrv:
            print(f"  HRV:      {hrv:.0f} ms")
        if breath:
            print(f"  Breath:   {breath:.1f} /min")
        if hr:
            print(f"  Heart:    {hr:.0f} bpm")
        print()


def cmd_alarms(args) -> None:
    """List alarms."""
    token, user_id, side = resolve_user_id(args)
    alarms_data = api_get_alarms(token, user_id)

    if args.json:
        print(json.dumps(alarms_data, indent=2))
        return

    alarms = alarms_data.get("alarms", [])
    if not alarms:
        print("No alarms configured.")
        return

    print(f"Alarms for {side} side:\n")

    for alarm in alarms:
        alarm_id = alarm.get("id", "?")[:8]
        enabled = alarm.get("enabled", False)
        time_str = alarm.get("time", "00:00:00")[:5]

        repeat = alarm.get("repeat", {}).get("weekDays", {})
        days = [d[:3].title() for d, v in repeat.items() if v]
        days_str = ", ".join(days) if days else "Once"

        status = "ON " if enabled else "OFF"
        vibration = "vibrate" if alarm.get("vibration", {}).get("enabled") else ""
        thermal = "thermal" if alarm.get("thermal", {}).get("enabled") else ""
        features = " ".join(filter(None, [vibration, thermal]))

        print(f"  [{status}] {time_str}  {days_str}")
        if features:
            print(f"        {features}")
        print(f"        ID: {alarm_id}...")


def cmd_alarm_set(args) -> None:
    """Set alarm time."""
    token, user_id, side = resolve_user_id(args)

    time_parts = args.time.split(":")
    if len(time_parts) == 2:
        time_str = f"{time_parts[0].zfill(2)}:{time_parts[1].zfill(2)}:00"
    else:
        time_str = args.time

    alarms_data = api_get_alarms(token, user_id)
    alarms = alarms_data.get("alarms", [])

    if not alarms:
        print("No alarms to modify. Create one in the app first.")
        return

    alarm = alarms[0]
    api_set_alarm(token, user_id, alarm["id"], {"time": time_str, "enabled": True})
    print(f"Alarm set to {time_str[:5]} on {side} side.")


def cmd_alarm_toggle(args, enable: bool) -> None:
    """Enable or disable alarm."""
    token, user_id, side = resolve_user_id(args)

    alarms_data = api_get_alarms(token, user_id)
    alarms = alarms_data.get("alarms", [])

    if not alarms:
        print("No alarms configured.")
        return

    alarm = alarms[0]
    api_set_alarm(token, user_id, alarm["id"], {"enabled": enable})
    state = "enabled" if enable else "disabled"
    print(f"Alarm {state} on {side} side.")


def cmd_schedule(args) -> None:
    """View temperature schedule."""
    token, user_id, side = resolve_user_id(args)

    try:
        result = fetch_temperature(token, user_id, use_cache_fallback=True)
    except RuntimeError as e:
        handle_offline_error(e)

    if args.json:
        print(json.dumps(result.data.get("settings", {}), indent=2))
        return

    settings = result.data.get("settings", {})
    schedule_type = settings.get("scheduleType", "unknown")
    smart = settings.get("smart", {})
    schedules = settings.get("schedules", [])

    print(f"{result.source_indicator()}")
    print(f"Schedule for {side} side:\n")
    print(f"Type: {schedule_type}")

    if smart:
        print(f"\nSmart temperatures:")
        print(f"  Bedtime:       {format_temp(smart.get('bedTimeLevel', 0))}")
        print(f"  Initial sleep: {format_temp(smart.get('initialSleepLevel', 0))}")
        print(f"  Final sleep:   {format_temp(smart.get('finalSleepLevel', 0))}")

    if schedules:
        print(f"\nSchedules:")
        for sched in schedules:
            enabled = "ON " if sched.get("enabled") else "OFF"
            time_str = sched.get("time", "00:00:00")[:5]
            days = sched.get("days", [])
            days_str = ", ".join([d[:3].title() for d in days]) if days else "None"
            print(f"  [{enabled}] {time_str}  {days_str}")


def cmd_doctor(args) -> None:
    """Health check - verify everything is working."""
    print("Eight Sleep CLI Health Check\n")
    print("=" * 40)
    errors = []

    # 1. Check config
    print("\n1. Configuration")
    config = load_config()
    if config.get("email") and config.get("password"):
        print(f"   ✓ Credentials configured ({config['email']})")
    else:
        print("   ✗ No credentials")
        errors.append("Run 'eight login' to configure credentials")

    # 2. Check token
    print("\n2. Authentication")
    token = None
    try:
        token = get_token()
        expires_in = int(token["expires_at"] - time.time())
        print(f"   ✓ Token valid (expires in {expires_in // 60}m)")
    except Exception as e:
        print(f"   ✗ Auth failed: {e}")
        errors.append(f"Authentication failed: {e}")

    # 3. Check API connectivity
    if token:
        print("\n3. API Connectivity")
        try:
            user_data = api_get_user(token)
            devices = user_data.get("user", {}).get("devices", [])
            print(f"   ✓ API reachable ({len(devices)} device(s))")
        except Exception as e:
            print(f"   ✗ API unreachable: {e}")
            errors.append(f"API connectivity failed: {e}")

        # 4. Check device
        print("\n4. Device Status")
        try:
            device, device_id, user_id, side = fetch_device_info(token)
            if device.get("online"):
                print(f"   ✓ Device online (you're on {side} side)")
            else:
                print(f"   ✗ Device OFFLINE (you're on {side} side)")
                errors.append("Device is offline. Check Pod power and network.")
        except Exception as e:
            print(f"   ✗ Device check failed: {e}")
            errors.append(f"Device check failed: {e}")

        # 5. Check temperature endpoint
        print("\n5. Temperature Endpoint")
        try:
            result = fetch_temperature(token, token["user_id"], use_cache_fallback=False)
            level = result.data.get("currentLevel", 0)
            print(f"   ✓ Temperature API OK (level {level})")
        except Exception as e:
            print(f"   ✗ Temperature endpoint failed: {e}")
            errors.append(f"Temperature endpoint failed: {e}")

    # 6. Check cache
    print("\n6. Cache")
    cache = load_cache()
    if cache:
        entries = []
        for key, entry in cache.items():
            age = int(time.time() - entry.get("timestamp", 0))
            entries.append(f"{key}: {format_age(age)} old")
        print(f"   ✓ {len(cache)} cached entries")
        for e in entries:
            print(f"     - {e}")
    else:
        print("   - Empty (will populate on use)")

    # Summary
    print("\n" + "=" * 40)
    if errors:
        print(f"\n⚠ {len(errors)} ISSUE(S) FOUND:\n")
        for i, err in enumerate(errors, 1):
            print(f"  {i}. {err}")
        sys.exit(1)
    else:
        print("\n✓ ALL CHECKS PASSED")


def cmd_version(args) -> None:
    """Show version."""
    print(f"eight {__version__}")


def cmd_completion(args) -> None:
    """Generate shell completion script."""
    shell = args.shell

    if shell == "bash":
        print('''
_eight_completion() {
    local cur prev commands
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"
    commands="login logout status temp on off whoami presence sleep alarms alarm-on alarm-off alarm-set schedule doctor version completion"

    case "$prev" in
        eight)
            COMPREPLY=($(compgen -W "$commands" -- "$cur"))
            ;;
        --side)
            COMPREPLY=($(compgen -W "left right" -- "$cur"))
            ;;
        completion)
            COMPREPLY=($(compgen -W "bash zsh fish" -- "$cur"))
            ;;
        *)
            COMPREPLY=($(compgen -W "--side --json --help --verbose" -- "$cur"))
            ;;
    esac
}
complete -F _eight_completion eight

# Add to ~/.bashrc: eval "$(eight completion bash)"
''')

    elif shell == "zsh":
        print('''
#compdef eight

_eight() {
    local -a commands
    commands=(
        'login:Configure credentials'
        'logout:Clear credentials'
        'status:Show device status'
        'temp:Set temperature'
        'on:Turn on'
        'off:Turn off'
        'whoami:Show current user'
        'presence:Check bed presence'
        'sleep:Show sleep metrics'
        'alarms:List alarms'
        'alarm-on:Enable alarm'
        'alarm-off:Disable alarm'
        'alarm-set:Set alarm time'
        'schedule:View temperature schedule'
        'doctor:Health check'
        'version:Show version'
        'completion:Generate shell completion'
    )

    _arguments -C \\
        '--side[Bed side]:side:(left right)' \\
        '--json[Output JSON]' \\
        '--verbose[Debug output]' \\
        '1: :->command' \\
        '*::arg:->args'

    case $state in
        command)
            _describe 'command' commands
            ;;
    esac
}

_eight "$@"

# Add to ~/.zshrc: eval "$(eight completion zsh)"
''')

    elif shell == "fish":
        print('''
complete -c eight -f

complete -c eight -n "__fish_use_subcommand" -a login -d "Configure credentials"
complete -c eight -n "__fish_use_subcommand" -a logout -d "Clear credentials"
complete -c eight -n "__fish_use_subcommand" -a status -d "Show device status"
complete -c eight -n "__fish_use_subcommand" -a temp -d "Set temperature"
complete -c eight -n "__fish_use_subcommand" -a on -d "Turn on"
complete -c eight -n "__fish_use_subcommand" -a off -d "Turn off"
complete -c eight -n "__fish_use_subcommand" -a whoami -d "Show current user"
complete -c eight -n "__fish_use_subcommand" -a presence -d "Check bed presence"
complete -c eight -n "__fish_use_subcommand" -a sleep -d "Show sleep metrics"
complete -c eight -n "__fish_use_subcommand" -a alarms -d "List alarms"
complete -c eight -n "__fish_use_subcommand" -a alarm-on -d "Enable alarm"
complete -c eight -n "__fish_use_subcommand" -a alarm-off -d "Disable alarm"
complete -c eight -n "__fish_use_subcommand" -a alarm-set -d "Set alarm time"
complete -c eight -n "__fish_use_subcommand" -a schedule -d "View temperature schedule"
complete -c eight -n "__fish_use_subcommand" -a doctor -d "Health check"
complete -c eight -n "__fish_use_subcommand" -a version -d "Show version"
complete -c eight -n "__fish_use_subcommand" -a completion -d "Generate shell completion"

complete -c eight -l side -d "Bed side" -a "left right"
complete -c eight -l json -d "Output JSON"
complete -c eight -l verbose -d "Debug output"

# Save to ~/.config/fish/completions/eight.fish
''')


# ─────────────────────────────────────────────────────────────────────────────
# Argument Parser Setup
# ─────────────────────────────────────────────────────────────────────────────

def add_side_arg(parser: argparse.ArgumentParser) -> None:
    """Add --side argument to a parser."""
    parser.add_argument("--side", "-s", choices=["left", "right"],
                        help="Bed side (default: your side)")


def build_parser() -> argparse.ArgumentParser:
    """Build the argument parser."""
    parser = argparse.ArgumentParser(
        prog="eight",
        description="Control your Eight Sleep Pod from the terminal."
    )
    parser.add_argument("--version", "-V", action="store_true", help="Show version")
    parser.add_argument("--verbose", "-v", action="store_true", help="Debug output")

    subparsers = parser.add_subparsers(dest="command", help="Commands")

    # login
    p = subparsers.add_parser("login", help="Configure credentials")
    p.add_argument("--email", "-e", help="Eight Sleep email")
    p.add_argument("--password", "-p", help="Eight Sleep password")
    p.set_defaults(func=cmd_login)

    # logout
    p = subparsers.add_parser("logout", help="Clear credentials and cache")
    p.set_defaults(func=cmd_logout)

    # status
    p = subparsers.add_parser("status", help="Show device status")
    p.add_argument("--json", "-j", action="store_true", help="Output JSON")
    add_side_arg(p)
    p.set_defaults(func=cmd_status)

    # temp
    p = subparsers.add_parser("temp", help="Set temperature (e.g., 68F, 20C, or -50)")
    p.add_argument("level", help="Temperature (68F, 20C) or level (-100 to 100)")
    add_side_arg(p)
    p.set_defaults(func=cmd_temp)

    # on
    p = subparsers.add_parser("on", help="Turn on")
    add_side_arg(p)
    p.set_defaults(func=cmd_on)

    # off
    p = subparsers.add_parser("off", help="Turn off")
    add_side_arg(p)
    p.set_defaults(func=cmd_off)

    # whoami
    p = subparsers.add_parser("whoami", help="Show current user and device info")
    p.set_defaults(func=cmd_whoami)

    # presence
    p = subparsers.add_parser("presence", help="Check if someone is in bed")
    p.add_argument("--json", "-j", action="store_true", help="Output JSON")
    p.add_argument("--side", "-s", choices=["left", "right"], help="Check specific side")
    p.set_defaults(func=cmd_presence)

    # sleep
    p = subparsers.add_parser("sleep", help="Show sleep metrics")
    p.add_argument("--days", "-d", type=int, default=7, help="Number of days (default: 7)")
    p.add_argument("--json", "-j", action="store_true", help="Output JSON")
    add_side_arg(p)
    p.set_defaults(func=cmd_sleep)

    # alarms
    p = subparsers.add_parser("alarms", help="List alarms")
    p.add_argument("--json", "-j", action="store_true", help="Output JSON")
    add_side_arg(p)
    p.set_defaults(func=cmd_alarms)

    # alarm-on
    p = subparsers.add_parser("alarm-on", help="Enable alarm")
    add_side_arg(p)
    p.set_defaults(func=lambda args: cmd_alarm_toggle(args, True))

    # alarm-off
    p = subparsers.add_parser("alarm-off", help="Disable alarm")
    add_side_arg(p)
    p.set_defaults(func=lambda args: cmd_alarm_toggle(args, False))

    # alarm-set
    p = subparsers.add_parser("alarm-set", help="Set alarm time (e.g., 7:30)")
    p.add_argument("time", help="Time in HH:MM format")
    add_side_arg(p)
    p.set_defaults(func=cmd_alarm_set)

    # schedule
    p = subparsers.add_parser("schedule", help="View temperature schedule")
    p.add_argument("--json", "-j", action="store_true", help="Output JSON")
    add_side_arg(p)
    p.set_defaults(func=cmd_schedule)

    # doctor
    p = subparsers.add_parser("doctor", help="Health check - verify everything works")
    p.set_defaults(func=cmd_doctor)

    # version
    p = subparsers.add_parser("version", help="Show version")
    p.set_defaults(func=cmd_version)

    # completion
    p = subparsers.add_parser("completion", help="Generate shell completion script")
    p.add_argument("shell", choices=["bash", "zsh", "fish"], help="Shell type")
    p.set_defaults(func=cmd_completion)

    return parser


# ─────────────────────────────────────────────────────────────────────────────
# Main Entry Point
# ─────────────────────────────────────────────────────────────────────────────

def main() -> None:
    global VERBOSE

    parser = build_parser()
    args = parser.parse_args()

    VERBOSE = args.verbose

    if args.version:
        cmd_version(args)
        return

    if not args.command:
        parser.print_help()
        sys.exit(1)

    try:
        args.func(args)
    except KeyboardInterrupt:
        print("\nAborted.")
        sys.exit(130)
    except Exception as e:
        if VERBOSE:
            import traceback
            traceback.print_exc()
        error(str(e))
        sys.exit(1)


if __name__ == "__main__":
    main()
